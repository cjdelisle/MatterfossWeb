'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _assign = require('babel-runtime/core-js/object/assign');

var _assign2 = _interopRequireDefault(_assign);

var _extends2 = require('babel-runtime/helpers/extends');

var _extends3 = _interopRequireDefault(_extends2);

var _promise = require('babel-runtime/core-js/promise');

var _promise2 = _interopRequireDefault(_promise);

var _classCallCheck2 = require('babel-runtime/helpers/classCallCheck');

var _classCallCheck3 = _interopRequireDefault(_classCallCheck2);

var _createClass2 = require('babel-runtime/helpers/createClass');

var _createClass3 = _interopRequireDefault(_createClass2);

var _http2 = require('./util/_http');

var _http3 = _interopRequireDefault(_http2);

var _querystring = require('querystring');

var _querystring2 = _interopRequireDefault(_querystring);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

/**
 *  Gfycat API wrapper class
 */
/*jslint node: true */

var Gfycat = function () {

  /**
   *  Create a Gfycat SDK object.
   *  @param {string} clientId - Client id retrieved from the developers portal.
   *  @param {string} clientSecret - Client secret retrieved from the developers portal.
   */
  function Gfycat() {
    var _ref = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {},
        clientId = _ref.clientId,
        clientSecret = _ref.clientSecret;

    (0, _classCallCheck3.default)(this, Gfycat);

    this.apiUrl = 'api.gfycat.com';
    this.apiVersion = '/v1';
    this.promiseSupport = typeof _promise2.default !== 'undefined';
    this.token = '';
    this.retryLimit = 2;

    if (!!clientId) this.clientId = clientId;
    if (!!clientSecret) this.clientSecret = clientSecret;
  }

  /**
   *  Authenticate using client id and secret, and store the retrieved access token in the class instance to be used implicitly by other methods.
   *  @callback {callback} [callback] - Optional callback function to be executed upon API response.
   *  @return {}
   */


  (0, _createClass3.default)(Gfycat, [{
    key: 'authenticate',
    value: function authenticate(callback) {
      var _this = this;

      var postData = {
        grant_type: 'client_credentials',
        client_id: this.clientId,
        client_secret: this.clientSecret,
        scope: 'scope' // Currently does not do anything
      };

      var options = {
        path: '/oauth/token',
        method: 'POST',
        postData: postData
      };

      if (callback) {
        this._request(options, function (err, data) {
          if (err) {
            return callback(err);
          } else {
            _this.token = data.access_token;
            return callback(null, data);
          }
        });
      } else {
        return new _promise2.default(function (resolve, reject) {
          _this._request(options, function (err, data) {
            if (err) reject(err);else {
              _this.token = data.access_token;
              resolve(data);
            }
          });
        });
      }
    }

    /**
     * Checking if the username is available / username exists / username is valid
     */

  }, {
    key: 'checkUsername',
    value: function checkUsername() {
      var _this2 = this;

      var _ref2 = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {},
          _ref2$username = _ref2.username,
          username = _ref2$username === undefined ? '' : _ref2$username;

      var callback = arguments[1];

      if (typeof username === 'undefined' || !username || username.length === 0) {
        return this.handleError('invalid username', callback);
      }

      var options = {
        path: '/users/' + username,
        method: 'GET'
      };

      if (callback) {
        this._request(options, function (err, data) {
          if (data) {
            return callback(null, false);
          } else {
            if ([401, 403, 422].indexOf(err.statusCode) > -1) {
              return callback(err);
            } else {
              return callback(null, true);
            }
          }
        });
      } else {
        return new _promise2.default(function (resolve, reject) {
          _this2._request(options, function (err, data) {
            if (data || [401, 422].indexOf(err.statusCode) > -1) {
              resolve(false);
            } else if (err && err.statusCode === 404) {
              resolve(true);
            } else {
              reject(err);
            }
          });
        });
      }
    }

    /**
     *  Search
     *
     *  @param {Object}
     */

  }, {
    key: 'search',
    value: function search() {
      var _ref3 = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {},
          search_text = _ref3.search_text,
          _ref3$random = _ref3.random,
          random = _ref3$random === undefined ? false : _ref3$random,
          _ref3$count = _ref3.count,
          count = _ref3$count === undefined ? 1 : _ref3$count,
          cursor = _ref3.cursor,
          first = _ref3.first;

      var callback = arguments[1];

      if (typeof search_text === 'undefined') {
        return this.handleError('Please specify a search_text attribute.', callback);
      }

      if (!!cursor && !!first) {
        return this.handleError('Please do not specify both cursor and first attributes. Only use one or the other.', callback);
      }

      var queryParams = {
        search_text: search_text,
        count: count
      };

      if (random) queryParams.random = true;
      if (cursor) queryParams.cursor = cursor;
      if (first) queryParams.first = first;

      var options = {
        path: '/gfycats/search',
        method: 'GET',
        query: queryParams
      };

      return this._request(options, callback);
    }

    /**
     * Get User info by ID
     */

  }, {
    key: 'getUserDetails',
    value: function getUserDetails() {
      var _ref4 = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {},
          userId = _ref4.userId;

      var callback = arguments[1];

      if (typeof userId === 'undefined' || userId === null || userId.length === 0) {
        return this.handleError('invalid userId', callback);
      }

      var options = {
        path: '/users/' + userId,
        method: 'GET'
      };

      return this._request(options, callback);
    }

    /**
     * Get Gfy info by ID
     */

  }, {
    key: 'getGifDetails',
    value: function getGifDetails() {
      var _ref5 = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {},
          gfyId = _ref5.gfyId;

      var callback = arguments[1];

      if (typeof gfyId === 'undefined' || gfyId === null || gfyId.length === 0) {
        return this.handleError('invalid gfyId', callback);
      }

      var options = {
        path: '/gfycats/' + gfyId,
        method: 'GET'
      };

      return this._request(options, callback);
    }

    /**
     * Get gifs that are related to a gif.
     */

  }, {
    key: 'getRelatedContent',
    value: function getRelatedContent(_ref6, callback) {
      var gfyId = _ref6.gfyId,
          count = _ref6.count,
          cursor = _ref6.cursor,
          from = _ref6.from;

      if (typeof gfyId === 'undefined' || gfyId === null || gfyId.length === 0) {
        return this.handleError('invalid gfyId', callback);
      }

      var queryParams = {};
      if (count) queryParams.count = count;
      if (cursor) queryParams.cursor = cursor;
      if (from) queryParams.from = from;

      var options = {
        path: '/gfycats/' + gfyId + '/related',
        method: 'GET',
        query: queryParams
      };

      return this._request(options, callback);
    }

    /**
     * Get a list of categories
     */

  }, {
    key: 'getCategories',
    value: function getCategories() {
      var _ref7 = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {},
          count = _ref7.count,
          gfyCount = _ref7.gfyCount;

      var callback = arguments[1];

      var options = {
        path: '/reactions/populated',
        method: 'GET',
        query: (0, _extends3.default)({}, count && { count: count }, {
          gfyCount: gfyCount || 1
        })
      };

      return this._request(options, callback);
    }

    /**
     * Get gifs for trending category
     */

  }, {
    key: 'getTrendingCategories',
    value: function getTrendingCategories(_ref8, callback) {
      var _ref8$tagName = _ref8.tagName,
          tagName = _ref8$tagName === undefined ? 'trending' : _ref8$tagName,
          _ref8$gfyCount = _ref8.gfyCount,
          gfyCount = _ref8$gfyCount === undefined ? 1 : _ref8$gfyCount,
          _ref8$cursor = _ref8.cursor,
          cursor = _ref8$cursor === undefined ? null : _ref8$cursor;

      var queryParams = {
        tagName: tagName,
        gfyCount: gfyCount,
        cursor: cursor
      };

      var options = {
        path: '/reactions/populated',
        method: 'GET',
        query: queryParams
      };

      return this._request(options, callback);
    }

    /**
     * User feed
     */

  }, {
    key: 'userFeed',
    value: function userFeed() {
      var _ref9 = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {},
          userId = _ref9.userId;

      var callback = arguments[1];

      if (typeof userId === 'undefined' || userId === null || userId.length === 0) {
        return this.handleError('invalid gfyId', callback);
      }

      var options = {
        path: '/users/' + userId + '/gfycats',
        method: 'GET'
      };

      return this._request(options, callback);
    }

    /**
     *  Trending
     */

  }, {
    key: 'trendingGifs',
    value: function trendingGifs() {
      var opts = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : { count: 1 };
      var callback = arguments[1];


      var options = {
        path: '/gfycats/trending',
        method: 'GET',
        query: opts
      };

      return this._request(options, callback);
    }

    /**
     *  Trending tags
     */

  }, {
    key: 'trendingTags',
    value: function trendingTags() {
      var opts = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
      var callback = arguments[1];

      var path = '/tags/trending';
      if (opts.populated) path += '/populated';
      // if (opts.cursor) queryParams.cursor = cursor;

      var options = {
        path: path,
        method: 'GET',
        query: opts
      };

      return this._request(options, callback);
    }

    /**
     *  Upload by URL
     */

  }, {
    key: 'upload',
    value: function upload(opts, callback) {
      if (!opts) return this.handleError('invalid Object', callback);

      var options = {
        path: '/gfycats',
        method: 'POST',
        postData: opts
      };

      return this._request(options, callback);
    }
  }, {
    key: 'stickers',
    value: function stickers() {
      var opts = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
      var callback = arguments[1];

      return this._request({
        path: opts.search_text ? '/stickers/search' : '/stickers',
        method: 'GET',
        query: {
          cursor: opts.cursor,
          count: opts.count,
          search_text: opts.search_text
        }
      }, callback);
    }

    /**
     *  Check upload status
     */

  }, {
    key: 'checkUploadStatus',
    value: function checkUploadStatus(gfyId, callback) {
      var options = {
        path: '/gfycats/fetch/status/' + gfyId,
        method: 'GET'
      };

      return this._request(options, callback);
    }
  }, {
    key: 'handleError',
    value: function handleError(message, callback) {
      if (callback) return callback(new Error(message));else return _promise2.default.reject(new Error(message));
    }

    /**
     *  Helper function for making http requests
     */

  }, {
    key: '_request',
    value: function _request(options, callback) {
      var _this3 = this;

      if (!callback && !this.promiseSupport) {
        throw new Error('Promises unsupported. Use callback functions instead.');
      }

      var query = typeof options.query !== 'undefined' ? _querystring2.default.stringify(options.query) : '';
      var apiPath = query ? options.path + '?' + query : options.path;

      var headers = {
        'Accept-Encoding': 'gzip,deflate'
      };

      if (this.token) headers.Authorization = 'Bearer ' + this.token;

      if (options.headers) {
        headers = (0, _assign2.default)(headers, options.headers);
      }

      var counter = options.counter || 0;
      if (counter >= this.retryLimit) {
        return this.handleError('Retry limit reached', callback);
      }

      var httpOptions = {
        request: {
          hostname: this.apiUrl,
          path: this.apiVersion + apiPath,
          method: options.method || 'GET',
          headers: headers
        },
        postData: options.postData || '',
        timeout: options.timeout || 30000,
        fmt: options.query && options.query.fmt
      };

      //If callback function is provided, override promise handlers.

      if (callback) {
        var resolve = function resolve(res) {
          callback(null, res);
        };

        var reject = function reject(err) {
          // authenticate returns 401 when the credentials are invalid.
          if (err.statusCode === 401 && options.path != '/oauth/token') {
            _this3.authenticate(function (err, res) {
              if (err) callback(err);else {
                options.counter = counter + 1;
                _this3._request(options, callback);
              }
            });
          } else {
            callback(err);
          }
        };
        _http3.default.request(httpOptions, resolve, reject);
      }

      //If no callback function is provided and promises are supported, use them.
      else {
          return new _promise2.default(function (resolve, reject) {
            _http3.default.request(httpOptions, resolve, reject);
          }).then(function (res) {
            return _promise2.default.resolve(res);
          }).catch(function (err) {
            // authenticate returns 401 when the credentials are invalid.
            if (err.statusCode === 401 && options.path != '/oauth/token') {
              return _this3.authenticate().then(function (res) {
                options.counter = counter + 1;
                return _this3._request(options);
              }).catch(function (err) {
                return _promise2.default.reject(err);
              });
            } else {
              return _promise2.default.reject(err);
            }
          });
        }
    }
  }]);
  return Gfycat;
}();

exports.default = Gfycat;